# Local Agent Weaver

## 1. 📜 프로젝트 개요 (Project Overview)

**Local Agent Weaver**는 로컬 환경에서 실행되는 독립적인 다중 에이전트 플랫폼 애플리케이션입니다. 이 프로젝트는 Gemini와 같은 강력한 대규모 언어 모델(LLM)의 핵심 아키텍처를 차용하여,
사용자가 자신만의 특화된 서브 에이전트 생태계를 동적으로 구성하고, 웹 기반의 그래픽 사용자 인터페이스(GUI)를 통해 이들과 상호작용할 수 있도록 하는 것을 목표로 합니다. 마치 VSCode의 포크 버전인
Cursor처럼, 이 프로젝트는 Gemini 앱의 개념을 바탕으로 한 독립적인 '에이전트 위버'로서의 역할을 지향합니다.

사용자는 단순히 프롬프트를 입력하는 것을 넘어, 각기 다른 전문성을 가진 서브 에이전트들을 조합하여 복잡한 문제를 해결하는 '에이전트 체인'을 동적으로 구성하고, 그 실행 과정을 투명하게 모니터링하며, 최종적으로
종합된 결과물을 얻을 수 있습니다.

---

## 2. ✨ 핵심 기능 (Core Features)

- **동적 에이전트 오케스트레이션 (Dynamic Agent Orchestration):**
    - **2단계 실행 모델:** 허브 에이전트는 사용자 요청에 대해 (1) 먼저 여러 서브 에이전트 중 어떤 것을, 어떤 순서로, 어떤 작업을 부여하여 호출할지에 대한 '에이전트 체인 계획'을 동적으로
      수립하고, (2) 그 다음 수립된 계획에 따라 각 서브 에이전트를 실행하여 얻은 결과를 최종적으로 종합하는 2단계 방식으로 동작합니다.
    - **투명성:** 허브 에이전트가 수립한 계획과 그 이유는 사용자에게 투명하게 공개되어, AI의 작업 흐름을 명확히 이해할 수 있습니다.

- **설정 파일 기반 시스템 (`agents.yml`):**
    - 모든 서브 에이전트의 종류, 역할, 설정 등은 `agents.yml`이라는 단일 설정 파일을 통해 정의됩니다. 코드를 직접 수정하지 않고, 이 YAML 파일만 수정하여 전체 에이전트 생태계를 손쉽게
      확장하고 관리할 수 있습니다.

- **독립적인 서브 에이전트 (Isolated Sub-agents):**
    - 각 서브 에이전트는 Node.js의 `child_process`를 통해 물리적으로 분리된 별도의 프로세스로 실행됩니다. 이를 통해 각 에이전트는 자신만의 독립된 메모리, 상태, 컨텍스트를 유지하여 서로에게
      영향을 주지 않는 안정적인 실행 환경을 보장받습니다.

- **내결함성 및 자가 치유 (Fault Tolerance & Self-Healing):**
    - **헬스체크:** 메인 러너는 모든 서브 에이전트의 상태를 주기적으로 확인합니다. (1) OS 레벨에서 프로세스의 생존 여부를 확인하고, (2) 각 에이전트 내장 TCP 서버와의 '핑퐁' 통신을 통해 응답
      가능 여부 및 신원까지 확인합니다.
    - **자동 복구:** 포트 충돌, 내부 로직 오류 등 특정 에러 코드를 반환하며 종료된 서브 에이전트에 대해, 원인을 파악하고 재시작하는 등의 자동 재해 복구 로직을 갖추고 있습니다.

- **다층적 대화 기록 관리 (Multi-layered Conversation History):**
    - **인메모리 문맥 (토큰 효율성):** 다음 LLM 호출에 사용될 인메모리 대화 기록은 '요약본'들만으로 구성하여, API 비용과 성능을 최적화합니다.
    - **영구 저장 (데이터 보존):** 각 턴(turn)의 전체 실행 결과(에이전트 체인 로그, 최종 답변, 요약본 등)는 `conversation.log` 파일에 JSON 형태로 저장되어, 애플리케이션을
      재시작해도 대화 기록이 보존됩니다.
    - **실시간 응답 (사용자 경험):** 클라이언트에게는 각 턴마다 상세한 에이전트 체인 로그와 전체 답변을 모두 포함한 완전한 JSON을 전달하여, 풍부한 정보를 제공합니다.

- **웹 기반 사용자 인터페이스 (Web-based UI):**
    - 모든 상호작용은 터미널이 아닌, React 기반의 웹 대시보드를 통해 이루어집니다. 사용자는 채팅 형식의 UI를 통해 프롬프트를 입력하고, 에이전트 체인 실행 과정과 최종 결과물을 시각적으로 확인할 수
      있습니다.

---

## 3. 🏗️ 아키텍처 (Architecture)

이 프로젝트는 백엔드와 프론트엔드가 명확히 분리된 모노레포 구조를 따릅니다.

```
/local-agent-weaver/
├── backend/                  # 백엔드 애플리케이션
│   ├── src/
│   │   ├── Server.ts         # API 서버 및 웹 서버 진입점
│   │   ├── main_runner.ts    # 에이전트 관리 및 오케스트레이션 로직 (서비스 계층)
│   │   ├── sub_agent_process.ts # 서브 에이전트 템플릿
│   │   ├── GeminiClient.ts  # Gemini API 통신 모듈
│   │   └── types.ts          # 공유 타입 정의
│   ├── agents.yml              # 에이전트 생태계 설정 파일
│   ├── contexts/               # 각 에이전트의 프롬프트(지침서) 디렉토리
│   ├── package.json            # 백엔드 의존성 및 스크립트
│   └── ...
└── frontend/                 # 프론트엔드 애플리케이션
    ├── src/
    │   ├── App.tsx             # 메인 애플리케이션 컴포넌트
    │   └── components/         # UI 컴포넌트 디렉토리
    ├── package.json            # 프론트엔드 의존성 및 스크립트
    └── ...
```

### 컴포넌트 역할

- **`Server.ts` (웹 서버 계층):** Express.js 기반의 웹 서버입니다. 프론트엔드로부터 오는 API 요청을 받아, `main_runner.ts`의 함수를 호출하고 그 결과를 반환하는 '정문'
  역할을 합니다. 또한 빌드된 프론트엔드의 정적 파일들을 서빙합니다.

- **`main_runner.ts` (서비스 계층):** 에이전트 시스템의 핵심 로직이 담긴 '엔진룸'입니다. `agents.yml`을 읽어 서브 에이전트 프로세스들을 실행/관리하고, 허브 에이전트의 2단계 실행(
  계획 수립 -> 결과 종합)을 오케스트레이션하며, `Server.ts`에 필요한 함수들을 제공하는 라이브러리 모듈입니다.

- **`sub_agent_process.ts` (서브 에이전트):** `main_runner.ts`에 의해 `fork`되는 개별 서브 에이전트의 템플릿입니다. 실행 시 자신의 설정 정보를 인자로 받아, 그에 맞는
  컨텍스트를 로드하고 허브로부터 작업을 받아 처리한 후 결과를 반환합니다.

- **`GeminiClient.ts`:** `@google/genai` SDK를 사용하여 Gemini API와의 모든 통신을 담당하는 중앙 집중형 모듈입니다.

- **`agents.yml`:** 시스템 내 모든 에이전트의 ID, 이름, 설명, 헬스체크 포트 등을 정의하는 중앙 설정 파일입니다.

### 통신 프로토콜

- **클라이언트 ↔ 백엔드:** HTTP/WebSocket을 통해 통신합니다. 클라이언트는 `/api/prompt`로 작업을 요청하고, 백엔드는 `FinalOutput` 타입의 JSON으로 응답합니다.
- **허브 ↔ 서브 에이전트 (작업):** Node.js의 내장 IPC(`process.send`, `process.on('message')`)를 통해 `AgentTask`와 `AgentResult` 객체를
  교환합니다.
- **허브 ↔ 서브 에이전트 (헬스체크):** 각 서브 에이전트가 개별 포트에서 실행하는 경량 TCP 서버를 통해 'ping-pong' 방식으로 생존 및 신원을 확인합니다.

---

## 4. 🚀 시작하기 (Getting Started)

### 사전 요구사항

- Node.js (v20 이상)
- npm

### 설치 및 실행

1. **API 키 설정:**
    - `backend/` 디렉토리 안에 `.env` 파일을 생성합니다.
    - 파일 안에 `GEMINI_API_KEY="YOUR_API_KEY"` 형식으로 자신의 Gemini API 키를 추가합니다.

2. **백엔드 의존성 설치 및 실행:**
   ```bash
   # /backend 디렉토리로 이동
   cd backend

   # 의존성 설치
   npm install

   # 개발 서버 실행
   npm run dev
   ```

3. **프론트엔드 의존성 설치 및 실행:**
   ```bash
   # 새 터미널을 열고 /frontend 디렉토리로 이동
   cd frontend

   # 의존성 설치
   npm install

   # 개발 서버 실행
   npm run dev
   ```

4. **애플리케이션 접속:**
    - 프론트엔드 서버가 시작되면 (보통 `http://localhost:5173`), 웹 브라우저로 해당 주소에 접속합니다.

---

## 5. 🔭 미래 계획 및 아이디어 (Future Roadmap)

이 프로젝트는 다음과 같은 방향으로 확장될 수 있습니다.

- **GUI 기반 에이전트 관리:**
    - 현재 `agents.yml` 파일을 직접 수정하는 방식에서 더 나아가, 웹 대시보드 UI를 통해 서브 에이전트를 동적으로 추가, 수정, 삭제하고 에이전트 체인 전략을 시각적으로 편집하는 기능을 구현합니다.
    - 이를 위해 `agents.yml`과 같은 설정 파일은 사용자가 직접 접근하지 않는 내부 데이터 저장소로 취급될 수 있습니다.

- **고급 아키텍처 도입:**
    - **선택적 문맥 전달 (Selective Context Passing):** 현재는 허브가 서브 에이전트 호출 시 전체 대화 기록을 전달하지만, 앞으로는 허브가 작업의 성격을 판단하여 해당 작업에 필요한
      최소한의 관련 문맥만 선별하여 전달하는 방식으로 고도화할 수 있습니다.
    - **상태 저장 서브 에이전트 (Stateful Sub-agents):** 여러 턴에 걸쳐 대화의 맥락을 기억해야 하는 복잡한 서브 에이전트를 위해, Redis 등을 이용한 외부 세션 저장소를 도입하여
      상태를 관리하는 기능을 추가할 수 있습니다.
    - **안정적인 통신 프로토콜:** 현재의 단순 IPC나 TCP 통신에서 더 나아가, gRPC나 메시지 큐(RabbitMQ, Redis Pub/Sub)를 도입하여 에이전트 간 통신의 안정성과 확장성을 높일 수
      있습니다.

- **배포 및 패키징:**
    - 전체 애플리케이션을 단일 실행 파일로 패키징하고, Homebrew와 같은 패키지 관리자를 통해 사용자가 쉽게 설치하고 실행할 수 있도록 배포 파이프라인을 구축합니다.
